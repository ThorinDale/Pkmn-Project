
For my final project, I decided to simulate a childhood video game with the concepts learned in object-oriented programming. The game franchise is called Pokémon, and my project is a simplified simulation of the actual video games developed by GameFreak Co., Ltd. The popularity of Pokémon is well-known, and the franchise was a driving factor in Japan's GDP. The Pokémon franchise accounted for 1/6th of Japan's GDP. Anyway, in this game, different creatures called Pokémon battle each other using their moves. Some of these moves do direct damage to the opponent, while other moves raise or lower its own or the opponents statistics. Just like the actual video games, each creature can only have up to four moves, and the user will type in 1, 2, 3, or 4 to select the corresponding move. The HP stat (Health Points) determine how much health the Pokémon has left in the battle. This stat decreases with every attack it received from an opponent. If a Pokémon's HP stat reaches 0, it is no longer able to battle. 
The entire project utilizes variations of design patterns. Some of the design patterns used are the abstract class inheritance, abstract factory, and class adaptor. One example of the abstract class is the Pkmn class. It holds the instance variables that a Pkmn class should have, such as name, type, attacks stat, defense stat, moves, and others. The actual objects are the actual Pkmn themselves, its name, stats, and moves as arguments to create the object from the abstract class. The Stat class is the parent class from which the HPStat and CoreStat inherits. The parent class's instance variables are 'protected' (rather than private), so that their variable are accessible in the child class. The abstract factory is used to create the actual Pokémon. The factory is actually embedded in the constructor of another class called BattleField. The factory is used so that on the surface, only the String name of the Pokémon is needed to create the Pokémon, while the factory is in charge of plugging in the stats and movesets. In this sense, it could also be a facade because the actual logistics of the Pokémon is handled elsewhere, not by the user. The adapter class is used in the Move class. The Move class has an abstract function called effect(). This design pattern is useful because each move shares commonalities. They all have an attack power, attack category, an attack type. However, they each have its own unique effect, which is written in an abtract effect() function. The actual moves themselves are classes, which implement their own unique effect(). For example, the move 'Sacred Fire' has a 50% chance of burning the opponent. The Move 'Ancient Power' has a 10% chance of raising the user's attack, defense, and speed stats. In the actual game, there are so many different kinds of moves and effects, trying to code this would take years. 
Some design patterns could have been better utilized, such as the adapter design pattern. I could have used an interface that implements, rather than an abstract class that inherits. I think a behavioral design pattern would also be useful, but the planning of the project came before the behavioral topics in class, so it was not really implemented. I have noticed that some of these design pattern concepts could be subconsciously used without even knowing it. As long as the code works as intended. Overall, the project was a lot of fun. 